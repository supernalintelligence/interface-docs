#!/usr/bin/env node
/**
 * Story Test Generator for Demo
 * 
 * This script demonstrates the complete Week 3/4 story pipeline:
 * 1. Load demo data contracts
 * 2. Parse .feature files with StoryParser
 * 3. Build dependency graph with StoryGraphBuilder (Week 4 - placeholder)
 * 4. Generate Playwright tests with GraphTestGenerator (Week 4 - placeholder)
 * 5. Show state-aware caching and checkpointing
 * 
 * Usage:
 *   npm run generate:story-tests
 *   npm run generate:story-tests -- --feature=counter
 *   npm run generate:story-tests -- --cache --checkpoints
 */

import { StoryParser, StateHasher, StoryCache, CheckpointManager } from "@supernal/interface-enterprise";
import { DemoComponentData } from '../../../demo/src/data/DemoComponentData';
import * as fs from 'fs';
import * as path from 'path';

interface GeneratorOptions {
  featureName?: string;
  outputDir?: string;
  enableCache?: boolean;
  enableCheckpoints?: boolean;
  verbose?: boolean;
}

class StoryTestGenerator {
  private cache: StoryCache;
  private checkpointManager: CheckpointManager;
  private options: GeneratorOptions;

  constructor(options: GeneratorOptions = {}) {
    this.options = {
      outputDir: path.join(__dirname, '..', 'tests', 'generated', 'stories'),
      enableCache: true,
      enableCheckpoints: true,
      verbose: false,
      ...options,
    };

    this.cache = new StoryCache();
    this.checkpointManager = new CheckpointManager();

    // Load demo data contracts into StoryParser
    StoryParser.loadRegistry(DemoComponentData);
  }

  async generate(): Promise<void> {
    console.log('üöÄ Story Test Generator - Week 3/4 Pipeline\n');
    console.log('üìã Configuration:');
    console.log(`   Output: ${this.options.outputDir}`);
    console.log(`   Cache: ${this.options.enableCache ? 'enabled' : 'disabled'}`);
    console.log(`   Checkpoints: ${this.options.enableCheckpoints ? 'enabled' : 'disabled'}`);
    console.log();

    // Step 1: Find feature files
    const featuresDir = path.join(__dirname, '..', 'features');
    const featureFiles = this.findFeatureFiles(featuresDir);

    if (featureFiles.length === 0) {
      console.error('‚ùå No .feature files found in', featuresDir);
      process.exit(1);
    }

    console.log(`üìÅ Found ${featureFiles.length} feature file(s):\n`);
    featureFiles.forEach(file => {
      console.log(`   - ${path.basename(file)}`);
    });
    console.log();

    // Step 2: Parse each feature file
    for (const featureFile of featureFiles) {
      const featureName = path.basename(featureFile, '.feature');
      
      if (this.options.featureName && featureName !== this.options.featureName) {
        continue; // Skip if filtering for specific feature
      }

      await this.processFeature(featureFile, featureName);
    }

    // Step 3: Show cache statistics
    if (this.options.enableCache) {
      console.log('\nüìä Cache Statistics:');
      const stats = this.cache.getStats();
      console.log(`   Total entries: ${stats.size}`);
      console.log(`   Cache hits: ${stats.hits}`);
      console.log(`   Cache misses: ${stats.misses}`);
      console.log(`   Hit rate: ${stats.hitRate.toFixed(1)}%`);
    }

    // Step 4: Show checkpoint statistics
    if (this.options.enableCheckpoints) {
      console.log('\nüîñ Checkpoint Statistics:');
      try {
        const allCheckpoints = this.checkpointManager.listCheckpoints();
        console.log(`   Total checkpoints: ${allCheckpoints.length}`);
        if (allCheckpoints.length > 0) {
          console.log(`   Latest: ${allCheckpoints[0].id}`);
        }
      } catch (error) {
        console.log(`   Error listing checkpoints: ${(error as Error).message}`);
      }
    }

    console.log('\n‚úÖ Story test generation complete!\n');
  }

  private findFeatureFiles(dir: string): string[] {
    if (!fs.existsSync(dir)) {
      return [];
    }

    const files = fs.readdirSync(dir);
    return files
      .filter(file => file.endsWith('.feature'))
      .map(file => path.join(dir, file));
  }

  private async processFeature(featureFile: string, featureName: string): Promise<void> {
    console.log(`\nüîç Processing: ${featureName}.feature`);
    console.log('‚îÄ'.repeat(60));

    const content = fs.readFileSync(featureFile, 'utf-8');
    
    // Parse feature metadata (simplified - full Gherkin parsing would be in Week 4)
    const lines = content.split('\n');
    const featureTitle = lines.find(l => l.startsWith('Feature:'))?.replace('Feature:', '').trim();
    
    console.log(`üìñ Feature: ${featureTitle}`);
    
    // Extract scenarios
    const scenarios = this.extractScenarios(content);
    console.log(`üìù Found ${scenarios.length} scenario(s)\n`);

    // Process each scenario
    for (const scenario of scenarios) {
      try {
        await this.processScenario(scenario, featureName);
      } catch (error) {
        console.error(`     ‚ùå Error processing scenario "${scenario.name}": ${(error as Error).message}`);
      }
    }
  }

  private extractScenarios(content: string): Array<{name: string, steps: string[], tags: string[]}> {
    const scenarios: Array<{name: string, steps: string[], tags: string[]}> = [];
    const lines = content.split('\n');
    
    let currentScenario: {name: string, steps: string[], tags: string[]} | null = null;
    let currentTags: string[] = [];

    for (const line of lines) {
      const trimmed = line.trim();
      
      if (trimmed.startsWith('@')) {
        currentTags = trimmed.split(/\s+/).filter(t => t.startsWith('@'));
      } else if (trimmed.startsWith('Scenario:')) {
        if (currentScenario) {
          scenarios.push(currentScenario);
        }
        currentScenario = {
          name: trimmed.replace('Scenario:', '').trim(),
          steps: [],
          tags: currentTags,
        };
        currentTags = [];
      } else if (currentScenario && (
        trimmed.startsWith('Given ') ||
        trimmed.startsWith('When ') ||
        trimmed.startsWith('Then ') ||
        trimmed.startsWith('And ')
      )) {
        currentScenario.steps.push(trimmed);
      }
    }

    if (currentScenario) {
      scenarios.push(currentScenario);
    }

    return scenarios;
  }

  private async processScenario(
    scenario: {name: string, steps: string[], tags: string[]},
    featureName: string
  ): Promise<void> {
    console.log(`  üìå Scenario: ${scenario.name}`);
    if (scenario.tags.length > 0) {
      console.log(`     Tags: ${scenario.tags.join(', ')}`);
    }

    let stateHash = '';
    let cacheHits = 0;
    let cacheMisses = 0;

    // Process each step
    for (let i = 0; i < scenario.steps.length; i++) {
      const step = scenario.steps[i];
      
      // Check if step references a data contract
      if (StoryParser.isDataContractReference(step)) {
        const match = step.match(/Components\.\w+\.\w+\.\w+/);
        if (match) {
          try {
            const reference = match[0];
            const resolvedData = StoryParser.resolveDataContract(reference);
            
            // Calculate state hash
            if (this.options.enableCache) {
              const hashResult = StateHasher.hash(resolvedData);
              stateHash = typeof hashResult === 'string' ? hashResult : hashResult.hash;
              
              if (this.options.verbose) {
                console.log(`       ‚Üí State hash: ${stateHash.substring(0, 16)}...`);
              }
              
              // Check cache (skip - cache.get requires StoryNode)
              const cached = null; // this.cache.get() requires a StoryNode object
              if (cached) {
                cacheHits++;
                if (this.options.verbose) {
                  console.log(`     ‚úì Step ${i + 1}: ${step.substring(0, 50)}... [CACHED]`);
                }
              } else {
                cacheMisses++;
                // Store in cache (skip - cache.set requires StoryNode)
                // this.cache.set() requires a StoryNode object
                if (this.options.verbose) {
                  console.log(`     ‚óã Step ${i + 1}: ${step.substring(0, 50)}... [MISS]`);
                }
              }
            }
            
            if (this.options.verbose) {
              console.log(`       ‚Üí Resolved: ${reference}`);
            }
          } catch (error) {
            console.error(`     ‚ùå Error resolving data contract in step ${i + 1}: ${(error as Error).message}`);
          }
        }
      }
    }

    // Create checkpoint if enabled
    if (this.options.enableCheckpoints && scenario.tags.includes('@checkpoint')) {
      const checkpointId = this.checkpointManager.createCheckpoint(
        `${featureName}/${scenario.name}`,
        new Map(), // Empty component states map for now
        [], // Empty executed nodes array
        scenario.name // Checkpoint name
      );
      if (this.options.verbose) {
        console.log(`     üîñ Checkpoint created: ${checkpointId}`);
      }
    }

    // Show stats for this scenario
    if (cacheHits > 0 || cacheMisses > 0) {
      const hitRate = cacheHits / (cacheHits + cacheMisses) * 100;
      console.log(`     Cache: ${cacheHits} hits, ${cacheMisses} misses (${hitRate.toFixed(0)}% hit rate)`);
    }
  }
}

// CLI handling
async function main() {
  const args = process.argv.slice(2);
  const options: GeneratorOptions = {
    verbose: args.includes('--verbose') || args.includes('-v'),
    enableCache: !args.includes('--no-cache'),
    enableCheckpoints: !args.includes('--no-checkpoints'),
  };

  // Parse --feature=<name>
  const featureArg = args.find(arg => arg.startsWith('--feature='));
  if (featureArg) {
    options.featureName = featureArg.split('=')[1];
  }

  const generator = new StoryTestGenerator(options);
  
  try {
    await generator.generate();
  } catch (error) {
    console.error('\n‚ùå Generation failed:', (error as Error).message);
    if (options.verbose) {
      console.error((error as Error).stack);
    }
    process.exit(1);
  }
}

main();

